// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveRoutingLogic = `-- name: GetActiveRoutingLogic :one
SELECT id, allocation_logic FROM routing_decision
WHERE status = 'active' LIMIT 1
`

type GetActiveRoutingLogicRow struct {
	ID              uuid.UUID
	AllocationLogic []byte
}

func (q *Queries) GetActiveRoutingLogic(ctx context.Context) (GetActiveRoutingLogicRow, error) {
	row := q.db.QueryRow(ctx, getActiveRoutingLogic)
	var i GetActiveRoutingLogicRow
	err := row.Scan(&i.ID, &i.AllocationLogic)
	return i, err
}

const getCourierByCode = `-- name: GetCourierByCode :one
SELECT id, name, code FROM courier
WHERE code = $1
`

type GetCourierByCodeRow struct {
	ID   uuid.UUID
	Name string
	Code string
}

func (q *Queries) GetCourierByCode(ctx context.Context, code string) (GetCourierByCodeRow, error) {
	row := q.db.QueryRow(ctx, getCourierByCode, code)
	var i GetCourierByCodeRow
	err := row.Scan(&i.ID, &i.Name, &i.Code)
	return i, err
}

const getRoutingDecisionLogs = `-- name: GetRoutingDecisionLogs :many
SELECT id, order_id, courier_id, routing_decision_id, status, reason, created_at, created_by FROM routing_decision_log
  WHERE ($3::uuid is NULL or order_id = $3::uuid)  
  AND ($4::uuid is NULL or courier_id = $4::uuid)  
  AND ($5::uuid is NULL or routing_decision_id = $5::uuid)
  AND ($6::text is NULL or status = $6::text)
  ORDER BY created_at DESC
  LIMIT $1 OFFSET $2
`

type GetRoutingDecisionLogsParams struct {
	Limit             int32
	Offset            int32
	OrderID           pgtype.UUID
	CourierID         pgtype.UUID
	RoutingDecisionID pgtype.UUID
	Status            pgtype.Text
}

func (q *Queries) GetRoutingDecisionLogs(ctx context.Context, arg GetRoutingDecisionLogsParams) ([]RoutingDecisionLog, error) {
	rows, err := q.db.Query(ctx, getRoutingDecisionLogs,
		arg.Limit,
		arg.Offset,
		arg.OrderID,
		arg.CourierID,
		arg.RoutingDecisionID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoutingDecisionLog
	for rows.Next() {
		var i RoutingDecisionLog
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.CourierID,
			&i.RoutingDecisionID,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inactivateCurrentActiveRoutingDecision = `-- name: InactivateCurrentActiveRoutingDecision :exec
UPDATE routing_decision SET status = 'inactive', updated_at = $1, updated_by = $2
WHERE status = 'active'
`

type InactivateCurrentActiveRoutingDecisionParams struct {
	UpdatedAt pgtype.Timestamp
	UpdatedBy uuid.UUID
}

func (q *Queries) InactivateCurrentActiveRoutingDecision(ctx context.Context, arg InactivateCurrentActiveRoutingDecisionParams) error {
	_, err := q.db.Exec(ctx, inactivateCurrentActiveRoutingDecision, arg.UpdatedAt, arg.UpdatedBy)
	return err
}

const insertActiveRoutingDecision = `-- name: InsertActiveRoutingDecision :exec
INSERT INTO routing_decision (
    id, status, allocation_logic, created_at, created_by, updated_at, updated_by
) VALUES (gen_random_uuid(), 'active', $1, $2, $3, $4, $5)
`

type InsertActiveRoutingDecisionParams struct {
	AllocationLogic []byte
	CreatedAt       pgtype.Timestamp
	CreatedBy       uuid.UUID
	UpdatedAt       pgtype.Timestamp
	UpdatedBy       uuid.UUID
}

func (q *Queries) InsertActiveRoutingDecision(ctx context.Context, arg InsertActiveRoutingDecisionParams) error {
	_, err := q.db.Exec(ctx, insertActiveRoutingDecision,
		arg.AllocationLogic,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const insertRoutingDecisionLog = `-- name: InsertRoutingDecisionLog :exec
INSERT INTO routing_decision_log (
    id, order_id, courier_id, routing_decision_id, status, reason, created_at, created_by
) VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7)
`

type InsertRoutingDecisionLogParams struct {
	OrderID           uuid.UUID
	CourierID         uuid.UUID
	RoutingDecisionID uuid.UUID
	Status            string
	Reason            pgtype.Text
	CreatedAt         pgtype.Timestamp
	CreatedBy         uuid.UUID
}

func (q *Queries) InsertRoutingDecisionLog(ctx context.Context, arg InsertRoutingDecisionLogParams) error {
	_, err := q.db.Exec(ctx, insertRoutingDecisionLog,
		arg.OrderID,
		arg.CourierID,
		arg.RoutingDecisionID,
		arg.Status,
		arg.Reason,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	return err
}
